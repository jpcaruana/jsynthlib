<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- $Id$ -->
<!--
  convention
    kbd:        for command line, filename
    var:        variable, method name

    Use structured text instead of B, I, or TT

    EM:         Indicates emphasis.
    STRONG:     Indicates stronger emphasis.
    CITE:       Contains a citation or a reference to other sources.
    DFN:        Indicates that this is the defining instance of the enclosed term.
    CODE:       Designates a fragment of computer code.
    SAMP:       Designates sample output from programs, scripts, etc.
    KBD:        Indicates text to be entered by the user.
    VAR:        Indicates an instance of a variable or program argument.
-->

<html>
<head>
<title>JSynthLib Programmer's Guide</title>
<link REV="made" HREF="mailto:jsynthlib-devel@lists.sourceforge.net">
</head>

<body bgcolor="#E5ED9D" text="Black" link="#3D75B4" vlink="#315480" alink="Red" leftmargin=40 topmargin=40>

<font face="Verdana,arial,helvetica" size="-1">

<h1>JSynthLib Programmer's Guide</h1>

Go to <a href="documentation.html">JSynthLib User's Guide</a>.

<h2><a name="toc">Table of Contents</a></h2>
<ol type="I">
  <li><a href="#common">Before we start...</a>
  <ol type="a">
    <li>Coding Style
    <li>Using Javadoc
    <li>Proper Use of Access Control Modifier
    <li>Code Sharing
    <li>Debug/Error Message
    <li>Exception Handling
  </ol>
  <li><a href="#compiling">How to Compile Files and Check Out from CVS</a>
  <li><a href="#writing">Writing a Synth Driver</a>
  <ol type="a">
    <li><a href="#wri_intro">Introduction</a>
    <ol>
      <li>How hard is it to add support for a new synthesizer to JSynthLib?
      <li>What do I need in order to add support for a new synthesizer?
      <li>Who owns the copyright to the code I contribute to JSynthLib?
    </ol>
    <li><a href="#layout">The Layout of JSynthLib</a>
    <li><a href="#apidoc">JSynthLib API Document</a>
    <li><a href="#areas">Synth Driver Structure</a>
    <li><a href="#wri_device">Writing a Device Class</a>
    <ol>
      <li>Create a file
      <li>Code Your Device Class
      <li>Keeping Persistent Parameters
      <li>Tell the core program about your driver
    </ol>
    <li><a href="#wri_single">Writing a Single Driver</a>
    <ol>
      <li>Create a file
      <li>Write the damn thing
      <li>Implement calculateChecksum Method
      <li>Implement storePatch and sendPatch Methods
      <li>Implement createPatch and editPatch Methods
    </ol>
    <li><a href="#wri_bank">Writing a Bank Driver</a>
    <li><a href="#wri_editor">Writing a Single Editor</a>
    <ol>
      <li>How to Add SysexWidgets</a>
      <li>The provided SysexWidgets</a>
      <li><a href="#modelsender">Param Model and Sender</a>
      <li>Action Listener</a>
    </ol>
    <li><a href="#wri_converter">Writing a Converter</a>
  </ol>
  <li><a href="#testing">Testing the driver</a>
  <ol type="a">
    <li><a href="#tst_intro">Introduction</a>
    <li><a href="#tst_single">Testing your Single Driver</a>
    <li><a href="#tst_bank">Testing your Bank Driver</a>
    <li><a href="#tst_editor">Testing your Editor</a>
  </ol>
  <li><a href="#faq">FAQ</a>
  <li><a href="#links">Related Documentation and Links</a>
  <ol type="a">
    <li>JSynthLib
    <li>Java Language
    <li>MIDI Specification
    <li>Applications
  </ol>
</ol>


<h2><a name="common" href="#toc">I. Before we start...</a></h2>
First a few words about writing code which will be shared by many developers.

Even if someone want write <strong>just</strong> a driver for his/her synth, the code will be read by others too.
Maybe some changes are necessary since an API change or another developer want take a look how a special issue is solved.

Following some rules makes the life easier for all who contribute to JSynthLib.

<h3>I.a. Coding Style</h3>
During developing driver you will/have to read source codes in
JSynthLib distribution.  Other programmers will read your source code
in the future. Use consistent coding style.

<a href="#codeconv">Code Conventions for the Java Programming Language</a> is a good reference.  Sample codes in
<a href="#examples">The Java Programming Language</a> by Ken Arnold and James Gosling (creators of Java
language) are good examples.  We encourage you to follow the coding
style in these documents especially you are editing source code in
core package.<br>
<p><strong>Important note:</strong> Please use an indentation level of 4 and a displayed tab width value of 8
(see <a href="#tabWidthFAQ">FAQ</a> for reasons).<br>

<h3>I.b. Using Javadoc</h3>

Add javadoc on important members (methods and fields).
<var>public</var> and </var>protected</var> member must be documented.

<h3>I.c. Proper Use of Access Control Modifier</h3>
This is important for codes under "core/". I believe this will help programmers best.
It would be much easier for me to write my driver if methods and fields were used properly.

I see many easy use of public or package (default) modifier in files under "core/".
If private or protected is used properly I don't have to do grep all files to see how a method or a field is used.<p>

Especially we have to be very careful to make a public (or package) field.
If you really need to access it, consider using protected or defining getFoo() or setFoo() method.<p>

This is a project to which many people are joining to.
Readability of code is very important.<p>

<h3>I.d. Code Sharing</h3>

Share the code if possible.  Use subclass (inheritance) or static
method properly.  If you copy a whole method, something wrong.  If you
divide a long method into several methods, the method would be more
easy to be overridden.  (More importantly a small method is easy to
maintain and would have less bug.)

<h3>I.e. Debug/Error Message</h3>

Use <var>ErrorMsg.reportStatus("message")</var> for debug message.
This way the message is only printed if JSynthLib is run in debugging
mode (AKA <kbd>java -jar JSynthLib.jar 2</kbd>). Don't use
<var>System.out.println</var>.<p>

Use <var>ErrorMsg.reportError("Title", "Message", e)</var> for error
message which users need to see.<p>

<h3>I.e. Exception Handling</h3>

Don't hide Exception just to stop compile error.
<pre>
    // BAD EXAMPLE
    try {
        ....
    } catch (Exception e) {
    }
</pre>

This makes debugging difficult.  Catch a specific Exception and put a
comment, if you know that it is not an error.

<pre>
    try {
        ....
    } catch (ASpecificException e) {
        // This is normal.
    }
</pre>

If it is an error or you are not sure, show a debug message.  (Of
course, implement proper error handling code if possible.)

<pre>
    try {
        ....
    } catch (ASpecificException e) {
        ErrorMsg.reportStatus(e);
    }
</pre>

Again catch a specific Exception.  Don't catch <var>Exception</var>
without good reason.

<h2><a name="compiling" href="#toc">II. How to Compile Files and Check Out from CVS</a></h2>

JSynthLib distribution includes source code.  First extract files from
the jar file.

<pre>
    mkdir JSynthLib
    cd JSynthLib
    jar xf ../JSynthLib-XXX.jar
</pre>

You can compile them by the following steps.

<pre>
    javac core/*.java
    javac synthdrivers/*/*/*.java synthdrivers/*/*.java
    # On Windows use semicolon (;) instead of colon (:).
    javac -classpath '.:Groovy.jar:asm.jar' org/jsynthlib/*/*/*.java org/jsynthlib/*/*.java
    javac *.java
</pre>

You may also use the following method:
<pre>
    find . -name "*.java" > js
    javac @js
</pre>

And Makefile and ANT build file are included.  You may compile
JSynthLib by simply typing;

<pre>
    make all
</pre>
or
<pre>
    ant
</pre>

If you are using <a href="http://www.eclipse.org/">Eclipse</a>, enable
the auto-compile feature.  Eclipse compiles necessary files in
background every time you save a file.<p>


Next, open up a Command Prompt or shell set to 50 row display and set
it to that directory. This is used to run JSynthLib for testing (the
50 row display helps keep error messages from scrolling off the screen
too fast). Make sure that the java[.exe] and javac[.exe] executables
are in your path for easy access.

<p>Important: Once you've extracted the .jar file and made changes to the
resultant files, you must launch JSynthLib using;
<pre>
    # On Windows use semicolon (;) instead of colon (:).
    java -classpath '.:Groovy.jar:asm.jar' JSynthLib -D 3
</pre>
instead of <kbd>java -jar JSynthLib.jar</kbd>. Otherwise you just run
the old .jar file and none of your alterations get used.  The command
line option '-D 3' gives you various debug messages from ErrorMsg class.
The messages help you.<p>

Although the source code for each version of JSynthLib is included in
the JSynthLib distribution, you may wish to download the latest
version of the source code to get any improvements made after the
latest release.  We sometimes have to change API to make JSynthLib
better. Your driver developed for the released JSynthLib may be
required some changes for the latest version.

You can downloaded the latest source code via CVS from SourceForge CVS
server.

<pre>
    cvs -d:pserver:anonymous@cvs.sf.net:/cvsroot/jsynthlib login
    cvs -z3 -d:pserver:anonymous@cvs.sf.net:/cvsroot/jsynthlib co JSynthLib
</pre>

For more detail go to CVS page on <a href="#cvssite">JSynthLib
SourceForge.net site</a>.<p>

<h2><a name="writing" href="#toc">III. Writing a Synth Driver</a></h2>

<h3><a name="wri_intro" href="#toc">III.a. Introduction</a></h3>

Alright, so you've got JSynthLib and like what it does. The problem is
that it doesn't support one of the synthesizers you own. Check the
feature request (RFE) tracker page on <a
href="http://sourceforge.net/projects/jsynthlib/">JSynthLib
SourceForge site</a> and drop a line to <a
href="mailto:jsynthlib-devel@lists.sourceforge.net">JSynthLib mailing
list</a> to find out if anyone is working on adding support for that
synth. You may find out that no one is. You decide to volunteer to add
support. Triumphantly you let us know your intention by adding a
message on the tracker and set down to hacking. This document is
designed to help you to complete the task.

<h4>III.a.1. How hard is it to add support for a new synthesizer to
JSynthLib?</h4>

The hardest part is simply becoming familiar with how JSynthLib works
and how it's laid out internally. Spend some time looking through the
driver code for other synthesizers and you'll basically pick it up by
osmosis. Once your familiar with what you have to do, actually doing
it shouldn't take too long. I've gotten librarian (not editing)
support for synthesizers hacked up in under two hours.  It depends of
course, on the complexity of the synthesizer and the quality of the
sysex specification.  Adding editing support can be a little more time
consuming, but is probably even more fun than writing librarian
support. I've spent anywhere between 3 or 4 hours (working on the
DR660 Editor) up to 5 days (working on the Matrix 1000 editor). If you
run into any trouble, you can email
<a href="mailto:jsynthlib-devel@lists.sourceforge.net">JSynthLib
mailing list</a> for help.

<h4>III.a.2. What do I need in order to add support for a new
synthesizer?</h4>

<ol>
<li>At the very least, you need a sysex specification for your
   synthesizer. In most cases, the sysex specification is located in
   the back of the manual, but this is not always the case.  Sometimes
   they are also available on the Internet if you look around
   enough.

<li>You probably also need the synthesizer you wish to add support for
   (for testing). While it might be possible to do it without the
   synthesizer, it would be pretty tough.

<li>You'll need a copy of the Java 1.4 (or higher) SDK. This is
   available for free from <a href="#javasite">java.sun.com</a>.
   This contains the various tools used to compile JSynthLib.

<li>You'll need a text editor in order to edit code. Anything will
   work. I wrote a significant part of the JSynthLib core code using
   EDIT.COM which comes with Windows. More recently, I've switched to
   <a href="#jedit">jEdit</a>, a Java based emacs-like
   programmer's editor with syntax highlighting and bracket matching.

   <p>To be compliant with the JSynthLib core sources it is best if you
   use an editor which supports our <a href=#codeconv>code conventions</a>
   (especially concerning the <a href="#tabWidthFAQ">tab settings</a>).

   <p>Some of the most active developers of this project started using <a
   href="http://www.eclipse.org/">Eclipse</a> (for setup have a look
   at the <a href="#setupEclipse">FAQ</a>).  It knows Java syntax
   well.  I can search reference and/or definition of a member,
   compile files auto-magically, has integrated CVS support, etc.

<li>Finally, you'll need to be able to program in Java. If you've
   programmed in C++ before, you can probably pick it up in about an
   hour (I did). If you are coming from C++ the most important thing
   to know is that Java passes all objects by reference, not
   value.
</ol>

<h4>III.a.3. Who owns the copyright to the code I contribute to
JSynthLib?<br></h4>

You do. Unless you specifically assign your copyright to me, you
retain ownership. Of course, <em>you must release your code under the GNU
General Public License</em> since it is considered a work derived from
JSynthLib, but in addition to releasing it under the GNU Public
License, you can do whatever else you want with it.  Put the following
lines at the top of <strong>each</strong> file.
<pre>
    /*
     * Copyright 20XX Your Name
     *
     * This file is part of JSynthLib.
     *
     * JSynthLib is free software; you can redistribute it and/or modify
     * it under the terms of the GNU General Public License as published
     * by the Free Software Foundation; either version 2 of the License,
     * or(at your option) any later version.
     *
     * JSynthLib is distributed in the hope that it will be useful, but
     * WITHOUT ANY WARRANTY; without even the implied warranty of
     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     * General Public License for more details.
     *
     * You should have received a copy of the GNU General Public License
     * along with JSynthLib; if not, write to the Free Software
     * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
     * USA
     */
</pre>

Don't forget editing the first line.

<h3><a name="layout" href="#toc">III.b. The Layout of JSynthLib</a></h3>

<i>Note: We are changing the package structure of JSynthLib.  This
section will be updated when the transition will be done.</i>

If you look at the JSynthLib directory, you'll see a number of files
and directories.  Since you are only adding support for a synthesizer,
and not working on the core program, you don't have to worry about
most of these. For you, the most important areas are the
<kbd>synthdrivers</kbd> directory where code pertaining to various
synthesizers are kept.

Under <kbd>synthdrivers</kbd> directory, you see many directories,
like KawaiK4.  As you see the names of directories has a convention,
manufacturer's name followed by model name.  (Usually one directory has
files for the Synth Driver for one synth model.  But you may have
synthdrivers for multiple synth models in one directory.)

In addition to the <kbd>synthdrivers</kbd> subdirectory, you will now
see <kbd>core</kbd> directory. Inside the core directory is all the
code for the main part of JSynthLib.  Feel free to look around.
(Probably you have to read source files which your code extends.)

<p>When you compile parts of JSynthLib, always do so from the main
JSynthLib directory. For example, to compile the file
synthdrivers\BossDR660Driver\BossDR660DrumkitDriver.java
sit in the main JSynthLib directory and type
<pre>
    javac synthdrivers\BossDR660Driver\BossDR660DrumkitDriver.java
</pre>.
Don't enter that directory and just type;
<pre>
    javac BossDR660DrumkitDriver.java # does not work
</pre>

<h3><a name="apidoc" href="#apidoc">III.c. JSynthLib API Document</a></h3>

You can make API document by executing;
<pre>
    javadoc -locale en_US -breakiterator -quiet -d doc/api_docs -use -author -version -overview doc/programming.html core/*.java
</pre>
View <kbd>doc/api_docs/index.html</kbd> with your favorite browser.
This document is on the top page with hyperlinks to class, interface,
and member definitions.

<h3><a name="areas" href="#toc">III.d. Synth Driver Structure</a></h3>

This section provides you a big picture of your Synth Driver.  First
let's describe some concepts.

<dl>
<dt>Device <dd>A class extends {@link core.Device} class.  It defines some
informations for your synthesizer, for example synth model name, MIDI
port assigned, etc.  And it has a list of drivers (Single Driver, Bank
Driver, and/or Converter) described below.

<dt>Single Patch <dd>Single Patch is a set of MIDI system exclusive
messages of a sound data, etc.

<dt>Single Driver <dd>Single Driver provides routines to support a
Single Patch.<p>

A Single Driver extends {@link core.IPatchDriver} class and allows JSynthLib to
detect a patch data for the synthesizer, to communicate with the
synthesizer.  Once this is written, JSynthLib will have Librarian
support for your synthesizer.<p>

A Single Driver optionally can have a Single Editor invoked by
IPatchDriver.editPatch() method.

<dt>Bank Patch <dd>Bank Patch (bulk dump patch) is a bank of single
patches.<p>

<dt>Bank Driver <dd>Bank Driver provides routines to support a Bank
Patch.<p>

A Bank Driver extends {@link core.IPatchDriver} and allows JSynthLib to combine a
single patch into a bank patch and to extract a single patch from a
bank patch. While this functionality isn't strictly necessary, it is
nice to have if your synth supports bulk dump patch.<p>

A Bank Driver can have a Bank Patch Editor.  But you don't have to
take care of it because usually the default editor can be used.

<dt>Converter <dd>A driver implements {@link core.IConverter} interface.  This is a
special driver.  Converter simply converts a patch, which is imported
from a file or MIDI input, into it's associated with to another
format. Most of synthdrivers don't use this.

<dt>Single Editor <dd>This is the fun part. This is a graphical
representation of the synthesizers internals which allows parameters
to be changed and edited.  It is invoked by a ISinglePatch.edit method.
</dl>

A Synth Driver communicates with JSynthLib core by using the following
interfaces.
<pre>
    {@link core.Device} class (required)

    {@link core.IDriver} interface
      {@link core.IPatchDriver} interface extends {@link core.IDriver} (required)
      {@link core.IConverter} interface (optional)

    {@link core.IPatch} interface
      {@link core.ISinglePatch} interface extends {@link core.IPatch} (required)
      {@link core.IBankPatch} interface extends {@link core.IPatch} (optional)
</pre>

All what you have to do is to implement java classes which implements
one of these interfaces.  Of course you don't have to write whole
code from scratch.  By extending existing classes, you can implement
your driver with reasonable effort.

Most of the current synthdrivers extend the following classes;
<pre>
    {@link core.Device} class

    {@link core.Driver} class implements {@link core.IPatchDriver}
    {@link core.BankDriver} class implements {@link core.IPatchDriver} (optional)
    {@link core.Converter} class implements {@link core.IConverter} (optional)

    {@link core.Patch} class implements {@link core.ISinglePatch} and {@link core.IBankPatch} class
</pre>

Actually the interfaces described above was just introduced in the
JSynthLib-0.20 release.

<h3><a name="wri_device" href="#toc">III.e. Writing a Device class</a></h3>

First you need to write a device file. This is very easy.

<h4>III.e.1. Create a File</h4>

Under <kbd>synthdrivers</kbd> directory, create a directory for your
synth.  Just copy an existing one, for example
<kbd>KawaiK4Device.java</kbd> and change it to suit your needs..  The
file name of the Device class must be <kbd>*Device.java</kbd>.  This
is the only rule for file names for a Synth Driver.<p>

<h4>III.e.2. Code Your Device Class</h4>

All what you have to do is to define two constructors. Here is from
<kbd>KawaiK4Device.java</kbd>.

<pre>
    /** Constructor for DeviceListWriter. */
    public KawaiK4Device() {
        super("Kawai", "K4/K4R", "F07E..0602400000040000000000f7",
              INFO_TEXT, "Brian Klock & Gerrit Gehnen");
    }

    /** Constructor for for actual work. */
    public KawaiK4Device(Preferences prefs) {
        this();
        this.prefs = prefs;

        addDriver(new KawaiK4BulkConverter());
        addDriver(new KawaiK4SingleDriver());
        addDriver(new KawaiK4BankDriver());
        // ... other drivers
    }
</pre>

The first constructor just defines various informations of your synth
and authors of this Device class.  This is used by the second
constructor and <kbd>DeviceListWriter</kbd> described in the next
section.<p>

The second constructor is used for the actual work.  It creates
drivers and add them onto the driver list by using addDriver method.<p>

<h4>III.e.3. Keeping Persistent Parameters</h4>

The second constructor has an argument,
<code>java.util.prefs.Preferences</code> object <code>prefs</code>.
By using this and overriding config() method, your driver can have
persistent parameters for your synth driver.  See actual code, for
example RolandTD6Device, for more details.

<h4>III.e.4. Tell the core program about your Synth Driver</h4>

You have to let JSynthLib know about your driver.  Create your Device
class without addDriver() method call.  Compile it, then execute the
following command on your command shell,

<pre>
    java core/DeviceListWriter
</pre>

This recreates the <kbd>synthdrivers.properties</kbd> file.<p>

Invoke JSynthLib, go to <code>Window->Preferences...->Synth
Driver</code>, and click <code>Add Device</code> button.  If all goes
well, you see your Device name is on the list.<p>

Now JSynthLib knows about your synth driver. Now the time to write
drivers :)

<h3><a name="wri_single" href="#toc">III.f. Writing a Single Driver</a></h3>

This section describe how to write a Single Driver by extending {@link
core.Driver}
class which is for {@link core.Patch} class.  Keep in mind that what you are doing
is to implement methods of {@link core.IPatchDriver} interface and methods which
{@link core.Patch} class requires.

<h4>III.f.1. Create a File</h4>

Copy a Single Driver from one of the other synthesizers and change its
name to match your synthesizers. Go through that file and change all
the references to that synthesizer to yours. I recommend using the
KawaiK4SingleDriver as a starting point because it is one of the most
simple drivers.<p>

<h4>III.f.2. Write the damn thing</h4>

Your Single Driver will be a subclass of the {@link core.Driver} class.  Take
a look at the API document and open up the file
<kbd>Driver.java</kbd>. All of the
variables and functions are documented as to their purpose. Also look
at your Single Driver code (which you copied from another synthesizer)
Between these two files you should be able to figure out what to
do.

<p>First, you change your constructor to provide the correct information
to the driver. This information is used by the functions in
Driver class to manipulate the data. If your synthesizer were very
simple, that would be just about all there was to writing the
driver. However, most synths have their unique quirks and features
that are impossible to describe using just data. Therefore you will
probably have to override some of the functions in Driver class to
perform for your synth.

<h4>III.f.3. Implement <var>calculateChecksum</var> Method</h4>

You may have to override the {@link core.Driver#calculateChecksum(Patch, int, int,
int)} and/or {@link core.Driver#calculateChecksum(Patch)} methods.<p>

{@link core.Driver#calculateChecksum(Patch, int, int, int)} actually
calculate
checksum.  The default method uses the most common algorithm used by
YAMAHA, Roland, and etc.  It adds all of the data bytes, takes the
lowest 7 bits, XORs them with 127 and adds one to get the checksum.
If your synth uses a different algorithm, override this method.<p>

{@link core.Driver#calculateChecksum(Patch)} is called by some methods
in {@link core.Driver} class.  If your synth does not use checksum,
override it by an empty
method.  If the patch for your synth consists of only one Sysex
Message, you don't have to override the method.  If your synth uses a
patch which consists of multiple Sysex Messages, you need to override
the method.  See, for example, <kbd>RolandTD6SingleDriver.java</kbd>.

<h4>III.f.4. Implement <var>storePatch</var> and <var>sendPatch</var>
Methods</h4>

<p>Looking at your driver code (which you stole from the KawaiK4 code
like I told you to).  You'll see that we had to implement two methods,
{@link core.Driver#storePatch(Patch, int, int)} and
{@link core.Driver#sendPatch(Patch)}.  storePatch sends a patch to a buffer in
your synth specified by a user, and sendPatch sends a patch to the
editing buffer in your synth.  This is common, since usually, slightly
different sysex messages are used to send a patch to the editing
buffer (and not overwrite a patch) or to a specific patch (and
overwrite). Change these functions to match your synth. If your synth
has no editing buffer, you'll need to overwrite the send method to
treat a specific patch location on the synth as the edit buffer it
(see the EmuProteusMPS Driver for an example of this).

<h4>III.f.5. Implement <var>createPatch</var> and <var>editPatch</var>
Methods</h4>

There are two functions that will always need to be overridden if you
wish to provide that functionality because there is no default version
in core\Driver.java. These are both easy to implement.<p>

One of these is the {@link core.Driver#createNewPatch} method which returns a new
(blank) patch.  You may use {@link core.DriverUtil#createNewPatch} for
this method.  See <kbd>RolandTD6SingleDriver</kbd> as an example.<p>

The other is the {@link core.Driver#editPatch} method which opens an Single
Editor window for the patch. You should be able to figure out how to
write these by looking at the code for the KawaiK4.

<p>There may be other functions in <kbd>Driver.java</kbd> that you will
need to override for your synth. In general, spend time looking at
that file, the drivers for all of the other synths, and API document
to get a feel for how things are done.

<p>Once your driver is working, JSynthLib now has Librarian support for
your synth. Celebrate. And send in the code to us so we can include it
in the next release of JSynthLib.

<h3><a name="wri_bank" href="#toc">III.g. Writing a Bank Driver</a></h3>

Basically, write a Bank Driver the same way you did the Single
Driver. Copy the BankDriver from the KawaiK4 or one of the other
synths and edit it to fit your needs. Change all the data in the
constructor to fit you synth. The Bank Driver subclasses
{@link core.BankDriver}. I recommend you look at that file and
figure out which functions you need to override.<p>

You may want to use your Single Driver in your Bank Driver.  You can
pass your Single Driver via the constructor of your Bank Driver.
Here is a part of RolandTD6Device Constructor;

<pre>
    public RolandTD6Device(Preferences prefs) {
        ...
        // add drivers
        TD6SingleDriver singleDriver = new TD6SingleDriver();
        addDriver(singleDriver);
        addDriver(new TD6BankDriver(singleDriver));
    }
</pre>

<h3><a name="wri_editor" href="#toc">III.h. Writing a Single Editor</a></h3>

All right, so you've written a Single Driver and maybe a Bank Driver and
now have Librarian support for your synthesizer. JSynthLib can load,
save and play patches. Pretty neat. But the real trick is to add
editing support for your synth.

<p>Writing an editor is a little bit harder than writing a driver. It
is harder because you have to write a Java Swing interface. Swing is
the default graphical toolkit that comes with Java. It is the
graphical interface which all of JSynthLib uses. If you don't know
Swing at all you might want to get a Java book, but you can get away
with just the <a href="#tutorial">Tutorial</a> on java.sun.com and the
<a href="#javaapi">API guide</a> that you can download when you
download the JDK.

<p>The job of your Single Editor class is to set up the interface for
your editor by using a number of functions and widgets provided by
JSynthLib and a number of Swing features.  It is invoked by
{@link core.IPatch#edit()} method.  It returns a {@link core.JSLFrame}
object.  What you have to do is create a class extending
{@link core.PatchEditorFrame} class which extends {@link core.JSLFrame}
class.  (You don't have to extend {@link core.PatchEditorFrame}, if you
want to create a JSLFrame object from scratch.)

<p>I like to set up all my sliders and CheckBoxes and figure out where
they go and what there ranges are first, get a nice pretty GUI on
screen and then go back and put in the numbers to make it actually
work. Basically you are going to create a number of JPanes and place
controls inside them using the {@link core.PatchEditorFrame#addWidget} method. Then you
insert these JPanes onto <var>scrollPane</var> (the background of the
window). <var>scrollPane</var> is created by JSynthLib for your
convenience.

<p>If you want Tabs and such, you can implement them the same way the
other editors do using the Swing feature. For a simple synth, you
can get away with just putting all the JPanes directly onto
<var>scrollPane</var>.

<p>You can do like with the Single Driver and start out by copying an
existing editor over and renaming the file, classes, constructor,
etc. I recommend the YamahaTX81z Editor since it is one of the
simplest Single Editor.

<p>Make sure you've taken a look at how all the other Single Editors are
set up, the code contained within them explains all better than I
could cope with mere words.

<h4>III.h.1. How to Add SysexWidgets:</h4>

JSynthLib comes with several SysexWidgets I've created which automatically
deal with sending sysex and whatnot.  A SysexWidget subclasses
{@link core.SysexWidget} class.  All you have to do is tell them
where to go and what values to send out. You create and layout them by
using {@link core.PatchEditorFrame#addWidget} method like this:

<pre>
    // example from the TX81z Editor
    addWidget(cmnPane,  // pane to put the SysexWidget on
              new ScrollBarWidget("Feedback", patch, 0, 7, 0,
                                  new ParamModel(patch, 100),
                                  new VcedSender(53)),
              1, 1,     // horizontal/vertical location
              3, 1,     // horizontal/vertical size
              18);      // fader number
</pre>

The first parameter is the JComponent (pane) you wish to put the SysexWidget
on. You would have created this pane previously as a JPane. Usually I
use panes to break the interface into functional sections (such as LFO
parameters, filter parameters, etc.).

<p>The second parameter is the SysexWidget to create, in this case a
{@link core.ScrollBarWidget}. Notice that the widget itself takes a few parameters, we'll
get to that in a moment.

<p>The next four parameters represent
the location and size of the SysexWidget within the Pane (Read up on
gridbaglayout in Sun's Java tutorial). They are (in order) the
horizontal location, the vertical location, the horizontal size, and
the vertical size).

<p>The last parameter is the fader number. Each SysexWidget
needs to have a unique fader number and they should go in order. label
all SysexWidgets with positive numbers except for CheckBoxes which get
negative numbers (buttons). So the sliders etc. would go
1, 2, 3, 4, 5.. and the CheckBoxes would go -1, -2, -3, -4, -5... etc.

<h4>III.h.2. The Provided SysexWidgets:</h4>

This section describes some of SysexWidgets provided.  See API
documents for other SysexWidgets and more details.<p>

<b>{@link core.ScrollBarWidget}</b> contain a label, a slider, and a numeric
readout of the value of the slider. They are the most common
SysexWidgets. The first parameter to the SysexWidget should be its label. the
second one will always be <var>patch</var>. The next two values are
the minimum and maximum values on the slider. The fifth value is a
value offset for the slider. This is usually zero, but gets used if
the parameter in the synthesizer is (for example) 0 through 127, but
should be displayed as -63 to +63). The last two parameters are a
<a href="#modelsender">Param Model and Sender</a> for this fader (we'll get
to those after we deal with some other SysexWidgets.).

<p><b>{@link core.ScrollBarLookupWidget}</b> are just like ScrollBarWidget but they
let the numeric readout contain values other than numbers. They are
used rarely. For example if a parameter can take the values of OFF,
1,2,3,4,5,6 or 7, you might use one. You wouldn't want to use a
ScrollBarWidget because the first value should be OFF, not zero. You could
also use a ComboBoxWidget in this situation. The constructor is about the
same as for a combo box.

<p><b>{@link core.ComboBoxWidget}</b> are drop-down list of choices that are best used
for non-numeric data (such as LFO shape). Here's an example of setting
up a ComboBoxWidget:

<pre>
    addWidget(panel,
              new ComboBoxWidget("EG Shift", patch,
                                 new ParamModel(patch, 20 + i*5),
                                 new AcedSender(i*5 + 4),
                                 new String[] {"96db", "48db", "24db", "12db"}),
              0, 4, 1, 1, 5);
</pre>

Parameters to the constructor are 1) a Label, 2) <var>patch</var>, 3)
a Param Model, 4) a Sender, and  5) an array of all the values that it can
contain.

<p><b>{@link core.CheckBoxWidget}</b> are used for parameters that can be either on
or off. Heres an example:

<pre>
    addWidget(lfoPane,
              new CheckBoxWidget("1", patch,
                                 new ParamModel(patch, 55 + 3*13),
                                 new VcedSender(3*13 + 8)),
              3, 6, 1, 1, -19);
</pre>

Parameters to the Constructor are 1) a Label, 2) <var>patch</var>, 3)
a Param Model, and 4) a Sender.

<p><b>{@link core.EnvelopeWidget}</b>, the final SysexWidget type, are vastly more complex
than the others.They represent several parameters on the synth, such
as the attack, decay, sustain, and release of a VCA envelope.

<p>Note that the fader number you give to an envelope widget represents
is its first fader number, and it will take as many as it needs starting at
that one to represent all of it's parameters.

<p>The constructor for an envelope widget takes a list
of {@link core.EnvelopeWidget.Node}s. Each Node is
one of the movable squares on the envelope. Some of these nodes are
stationary, some contain two parameters on the synth and can be moved
vertically and horizontally, and others contain only one parameter and
can therefore be moved in only one direction. Here is an example:

<pre>
    EnvelopeWidget.Node[] nodes = new EnvelopeWidget.Node[] {
        // origin
	new EnvelopeWidget.Node(0, 0, null, 0, 0, null, 0, false, null, null, null, null),
        // delay time
	new EnvelopeWidget.Node(0, 100, new K4Model(patch, 30 + i),
	        		0, 0, null,
	        		0, false, new K4Sender(34, i), null, "Dly", null),
        // atack time
	new EnvelopeWidget.Node(0, 100, new K4Model(patch, 62 + i),
	        		100, 100, null,
	        		25, false, new K4Sender(45, i), null, "A", null),
        // decay time and sustain level
	new EnvelopeWidget.Node(0, 100, new K4Model(patch, 66 + i),
				0, 100, new K4Model(patch, 70 + i),
				25, false, new K4Sender(46, i), new K4Sender(47, i), "D", "S"),
        // null node for constant length horizontal line
	new EnvelopeWidget.Node(100, 100, null,
	        		EnvelopeWidget.Node.SAME, 0, null,
				0, false, null, null, null, null),
        // release time
	new EnvelopeWidget.Node(0, 100, new K4Model(patch, 74 + i),
				0, 0, null,
				0, false, new K4Sender(48, i), null, "R", null),
    };
    addWidget(panel,
              new EnvelopeWidget("DCA Envelope", patch, nodes),
              0, 0, 3, 5, 33);
</pre>

As you see, the Envelope Widget takes a label, followed by
<var>patch</var> and then an array of EnvelopeWidget.Node objects. The
parameters given to the EnvelopeWidget.Node constructor have the
following meaning:

<pre>
    public Node(int minx, int maxx, ParamModel pmodelx,
                int miny, int maxy, ParamModel pmodely,
                int basey,
                boolean invertx,
                SysexSender senderx, SysexSender sendery,
                String namex, String namey)
</pre>

<small>
<dl>
<dt>minx, maxx, miny, maxy <dd> The minimum/maximum value permitted by
the synth parameter which rides the X/Y axis of the node.

<dt>pmodelx, pmodely <dd>The
Param Model which provides reading/writing abilities to the sysex
data representing the parameter.

<dt>basey <dd>Sometimes you don't want zero on a
Y-axis-riding-parameter to be all the way down at the bottom. This
gives it a little bit of rise. <var>basey</var> will be added to all Y
values. (This doesn't change the function of the EnvelopeWidget, but
makes it look nicer and possibly be more intuitive to use.)

<dt>invertx <dd>Sometimes on an X-axis-riding attribute 0 is the fastest,
other times it is the slowest. This allows you to choose.

<dt>senderx, sendery <dd>The Senders which send sysex messages to the synths when
the Node is moved.

<dt>namex, namey <dd>The names of the parameters riding each access.
</dl>

**Using <var>null</var>s for the Param Models and Senders and setting
min to max means that a node is stationary on that axis and has no
related parameter.

**Using EnvelopeWidget.Node.SAME for miny means that the
height remains at whatever the previous node was at.
</small>

<p>I hope that made sense, if not, just take a look at the way
EnvelopeWidget are used by various single editors.

<p>
<b>{@link core.CheckBoxWidget}</b>,
<b>{@link core.KnobWidget}</b>,
<b>{@link core.KnobLookupWidget}</b>,
<b>{@link core.LabelWidget}</b>,
<b>{@link core.PatchNameWidget}</b>,
<b>{@link core.ScrollBarLookupWidget}</b>,
<b>{@link core.VertScrollBarWidget}</b>,
<b>{@link core.SpinnerWidget}</b>,
and <b>{@link core.TreeWidget}</b> are also provided.

<h4><a name="modelsender" href="#toc">III.h.3. Param Model and Sender</a></h4>

Param Model (Parameter Model) and Sender are objects which communicate
data between the synth and the SysexWidgets.

<p>A <strong>Sender</strong> is a class object which implements
{@link core.SysexWidget.ISender} interface.
Every time a SysexWidget moves, its Sender
gets told. The job of the Sender is to send a Sysex string to the
synth informing it of the change. Usually a Single Editor will have
one or more Sender. Sometimes more than one is used because a synth
uses more than one method to transfer the data. Here's an example of a
Sender which extends {@link core.SysexSender} class from
the YamahaTX81z Editor:

<pre>
    class VcedSender extends SysexSender {
        int parameter;
        byte[] b = new byte [7];
        public VcedSender(int param) {
            parameter = param;
            b[0] = (byte) 0xF0; b[1] = (byte) 0x43;
            b[3] = (byte) 0x12; b[4] = (byte) parameter; b[6] = (byte) 0xF7;
        }
        public byte[] generate (int value) {
            b[2] = (byte) (16 + channel - 1); b[5] = (byte) value;
            return b;
        }
    }
</pre>

The TX81z has two Senders, VcedSender (shown above) and AcedSender
(not shown), because it uses two slightly different methods to transfer
two types of data (called Vced and Aced in the TX81z manual).

<p>The constructor for a SysexSender takes a parameter representing which
parameter a particular instance of the Sender should control and
creates a sysex message containing all necessary information except
for the data value to be transmitted and the channel (Device ID) to transmit
on. When the SysexWidget attached to this instance of the SysexSender moves,
the <var>generate</var> method of the SysexSender gets called with the value to
send. The generate function simply puts the value and channel into the
message and returns it.

<p>In addition to sending changes to the synth, we want to keep track
of the changes to the patch so that when we next call up this patch
the changes are there. We also want to be able to set the SysexWidgets
to the correct values for a particular patch when the Single Editor is
opened. This is what the <strong>Param Model (Parameter Model)</strong>
is for.

<p>Param Model is a class object which implements
{@link core.SysexWidget.IParameter} interface.  The default Param Model,
defined by {@link core.ParamModel} class, is used by the YamahaTX81z editor. Its
constructor takes two parameters, the <var>patch</var> being edited
and the <var>offset</var> into the patch of the
value. Sometimes the default can be used, other times it is either
necessary or more convenient to subclass ParamModel to make your own
Model. Here's an example from the KawaiK4 Editor:

<pre>
    class K4Model extends ParamModel {
        public int bitmask;
        public int mult;
        public K4Model(Patch p, int o) {
            ofs = o + 8; patch = p; bitmask = 255; mult = 1;
        }
        public K4Model(Patch p, int o, int b) {
            ofs = o + 8; patch = p; bitmask = b;
            if ((bitmask&  1) ==   1) mult =   1; else
            if ((bitmask&  2) ==   2) mult =   2; else
            if ((bitmask&  4) ==   4) mult =   4; else
            if ((bitmask&  8) ==   8) mult =   8; else
            if ((bitmask& 16) ==  16) mult =  16; else
            if ((bitmask& 32) ==  32) mult =  32; else
            if ((bitmask& 64) ==  64) mult =  64; else
            if ((bitmask&128) == 128) mult = 128;
        }
        public void set(int i) {
            patch.sysex[ofs] = (byte) ((i*mult) + (patch.sysex[ofs]&(~bitmask)));
        }
        public int get() {
            return ((patch.sysex[ofs]&bitmask)/mult);
        }
    }
</pre>

<p>In the case of the KawaiK4, we couldn't just use default Param Model, because
some Kawai K4 parameters are bitmasks stored in the same byte as other
parameters. The above class K4Model, takes care of deciphering the
bitmasks. The Model is designed to take the same two parameters as
ParamModel. It implements two functions in addition to its
constructor. the set function is given a value and must set its
parameter to the value. the get must return the value of its
parameter.

<p>Note how the Param Models and Senders are used in the addWidget functions in
the various editors. addWidget doesn't care if you use the default
Param Model or if you implement your own. This makes the
SysexWidgets much more extensible. They can be used without needing to know
how exactly the data is supposed to be accessed. The Model and Sender
takes care of that.

<p>This all probably sounds more complex than it really is, just take a
look at the editors for various other synths, try changing some things
maybe to see how they work. It shouldn't be too hard to figure out,
but I'm not too good at explaining.

<h4>III.h.4. Action Listener</h4>

Swing provides a construct known as an action listener which
allows you to write a routine which is called whenever a SysexWidget is
moved. You never need to use these for dealing with built in JSynthLib
SysexWidgets because they take care of it themselves. It is useful however
if you want to have a SysexWidget do something more than control the
synth. the Yamaha TX81x editor, for example, uses one to change the
picture of the algorithm every time the 'algorithm' slider is
moved.

<h3><a name="wri_converter" href="#toc">III.i. Writing a Converter</a></h3>

<i>!!!FIXME!!! Describe the situation where Converter is used.</i>

<h2><a name="testing" href="#toc">IV. Testing Your Driver...</a></h2>

<em>This section of the Documentation was written by Yves Lefebvre.</em>

<h3><a name="tst_intro" href="#toc">IV.a. Introduction</a></h3>
<p>This is an attempt to do a test plan when writing a new driver for
JSynthLib. It take little time to do and may help finding problem
before the driver is available publicly.


<p>First thing to do: you must do some single dump and some bank dump
from your synth to your computer without using JSynthLib (I use
Cakewalk to do that but there should be some simple freeware to do
this). Save those dump in .syx format (binary). Remember, we are not
using JSynthLib at his point in order to have something "clean" to
refer to when testing the new driver.

<p>One important note : It seems that some synth could have "bugs" in
their factory patches. So if you resend those patch to the synth, they
will be "corrected". To test this, you can simply resend the bank dump
from your PC to the synth and do a new bank dump from synth to PC. If
there are difference and the first bank dump and the second, this is
probably the problem I mention. Normally, resending the second dump
should be consistent after that. Any dump from synth to PC should be
identical to the second dump since the synth has now "corrected" the
original dump! I had this problem with some specific patch of my Nova
after restoring original patches on the unit with the "Restore from
ROM" command. I had spent some time figuring out the difference
between dump so I'm warning you not to do the same mistake!

<p>Now, redo the same thing (single dump and bank dump) but this time,
change your device id number on the synth (sometime call global MIDI
channel). Those new dump may have some byte different or not. In most
case, single dump will be identical while bank dump may be different.

<h3><a name="tst_single" href="#toc">IV.b. Testing your Single Driver</a></h3>

<ul>
<li>Try to open a "clean" .syx file from JSynthLib and send it to the
edit buffer of your synth. Try it to see if the name and sound seems
OK. Do a dump (with external soft) and compare the file, they should
be identical. Make sure that the patch is really in the edit buffer
(and not written in memory) by changing patch on the synth and going
back to the patch number it was before the send: the patch you just
send should not be there (This may vary with some synth Model).

<li>Try to do a single patch dump to JSynthLib. Check that the patch
name is correct in JSynthLib. Export it to a .syx file and compare it
(diff) with the original "clean" version. Should be the same. (Those
steps will confirm that loading external file and receiving/sending a
dump give the same result)

<li>Try to store this patch at different location in the synth. At
least, try to store in patch 0 or 1 and to the highest patch number of
your synth. Do that in every user bank if possible. Verify that the
patch appear in all the location you save it.

<li>Create a new patch with JSynthLib and send it to your synth. Make
sure the new patch didn't do anything wrong on the synth (if your new
patch is all 0 with a name, some synth may react strangely to invalid
combination of values). If you want to play safe, your createNewPatch
method could construct a valid default patch for your synth: just do a
dump of a simple patch and integrate this in the code.

<li>Now, redo all those step with a different id number on the
synth. Change JSynthLib accordingly to that new Id (channel
number). Some time, it's possible you left a bug if you didn't test
with a different ID (channel number).
</ul>

<h3><a name="tst_bank" href="#toc">IV.c. Testing your Bank Driver</a></h3>
<ul>
<li> Open a "clean" .syx bank file with JSynthLib. Make sure that all
individual patch name make sense.

<li>Send one patch from the bank to your synth. Make a dump (from
your synth) of that single patch with another software. Now, do a diff
of this dump with a previously made dump of that same patch. This will
make sure that extracting a patch from a bank and sending it to the
synth gave the exact same thing. You should really do a binary compare
of the file since just playing it is not enough. Even if some
parameter are sent wrong, the patch may sound correct to your ear, so
you need to do a real compare.

<li>Erase all bank memory on your synth. Now, send the whole bank
from JSynthLib to your synth. Do a dump from the synth to your
external software. The .syx file should be the same than the original
one. This is not the same thing than the previous step: extracting a
single patch from a bank and sending a whole bank is very
different. Note: one potential problem here is that some synth may
need more time to "digest" a big bank dump from your PC. In those
cases, you should put some delay in your code until you find a safe
speed.

<li>Try sending your bank to all possible banks in the synth and
verify their integrity.

<li>Now, you should redo some of those steps with a different channel
number, just to make sure. Note that the bank .syx file will likely
have the channel byte different so you need to extract a "clean" bank
with the new channel first from your synth.
</ul>
<h3><a name="tst_editor" href="#toc">IV.d. Testing your Editor</a></h3>

<p>Note: I never write an editor but here are some suggestions:
<ul>
<li>Usually, modifications done in the editor are sent in real-time
to your synth.  However, the editor must also make the same
modification in the single patch that is edited. To test that it works
correctly, you should made some modification in the editor and save
the patch (do not send that patch to the edit buffer of your synth).
Now, on your synth, the same patch should be in the edit buffer since
all single edit will have send sysex for every parameter changed.  Do
a dump from your synth to PC and compare it to the patch JSynthLib
just created.  They should be identical. Normally, you should try each
fader or knob in the editor to be sure they are controlling the
correct parameter. Just move each one at random when creating the
patch. If you do that some time (random edit, saving and comparing the
file), chance are the editor behave correctly.
</ul>
<p>Note: I suggest to move
each fader at random because putting all of them to 0 or max is not a
good idea since your editor may send knob info to the wrong place and
you will not be able to detect it by comparing the .syx file!


<p>Last step, send your new driver for integration in the next release
of JSynthLib!

<p>Yves Lefebvre<br>
ivanohe@abacom.com<br>
www.abacom.com/~ivanohe

<h2><a name="faq" href="#toc">V. FAQ</a></h2>

<h3>How can I send a bug report?</h3>

Send the following information to Tracker on <a
href="http://sourceforge.net/projects/jsynthlib/">JSynthLib
SourceForge site</a> or <a
href="mailto:jsynthlib-devel@lists.sourceforge.net">jsynthlib-devel
mailing list</a>.

<ol>
<li> Output message in debug mode.  Invoke JSynthLib with option '2'.
This will output debug information including Java version, OS type,
etc.
<li> A specific way to reproduce the bug.
<li> Any other useful <strong>'fact'</strong>, other than 'guess'.
</ol>

<h3>Is there any tips for debug?</h3>

Of course, nothing ever works the first time. Its never as easy as it
should be. If you have problems getting the synth to do what your
editor or driver is telling it to do. here's two debugging tricks I
use.

<ol>
<li>This is pretty common, but just sprinkle
<var>System.out.println</var> statements through out the troublesome
code. Get a good idea of what values are what when and look for
something that shouldn't be. Better yet, use
<var>ErrorMsg.reportError("ErrorMsg goes here")</var> instead.

<li>Use a MIDI cable to connect your computer's MIDI out to MIDI
in. Use build in MIDI Monitor Window or get a program (for example <a
href="#midiox">MIDI-OX</a> for Windows) from the Internet to print out
all incoming MIDI messages. Now you can see what messages your
editor/driver is sending and you can check them for correctness.

<!-- Just reinvoking JSynthLib should be enough.
<li>When you are working on a driver and it doesn't seem to be doing
what the code looks like it should do, one common problem is that if
you make a change to the Constructor, you need to go into JSynthLib
and remove the driver from the SynthConfig Dialog box and then add it
again. Otherwise the newly Changed constructor isn't getting
called.
 -->
</ol>

<h3><a name="tabWidthFAQ"></a>Why shall I use an indentation level of 4 with a displayed tab width of 8?</h3>

For indentation level, any level is OK.  But we need a standard to
work in a team.  We choose the coding style used in "Programming
Language Java" out of respect for the creators of Java language as
the standard.  Therefor we recommend the indentation level of 4.<p>

The reason for displayed tab width of 8 is compatibility with the
following essential tools:

<ul>
  <li>... viewcvs, the CVS browser that SourceForge uses.</li>
  <li>... Notepad, the default editor of Microsoft Windows.</li>
  <li>... Unix command line tools like cat, less, tail, ...</li>
</ul>

We believe most of tool can support the setting above.
An open source IDE that supports these settings is e.g. <a href="#setupEclipse">Eclipse</a>.
Text editors that also support it are e.g. <a href="http://www.jedit.org/">jEdit</a> and
<a href="http://scintilla.sourceforge.net/SciTE.html">SciTE</a> which are both open source and availabe for Linux, Mac OS X and Windows like Eclipse.

<h3><a name="setupEclipse"></a>How to set up <a href="http://www.eclipse.org/">Eclipse</a> for JSynthLib?</h3>

Here is the setting I'm using for Eclipse 3.0.
<ol>
<li> <kbd>Preferences->Java->Editor->Displayed tab width</kbd> set to '8'.

<li> On <kbd>Project->Java Build Path->Source</kbd> tab, select
<kbd>Excluded...</kbd>, and click <kbd>Edit...</kbd>.  Add
<kbd>midiprovider/**</kbd> onto <kbd>Exclusion patterns:</kbd>.

<li> On <kbd>Project->Java Build Path->Library</kbd> tab, add
<kbd>groovy.jar</kbd> and <kbd>asm.jar</kbd>.

<li> If you installed the Javadoc of JDK,
<kbd>Preferences->Java->Installed JREs->Edit->Javadoc URL</kbd> set to
the directory where you installed the Javadoc. You can see short
description by moving mouse cursor on a class or a member.  You can
see full documentation by hitting <kbd>Shift-F2</kbd> after selecting
a class or member.

<li> Don't forget to generate javadoc of JSynthlib by
<kbd>Project->Generate Javadoc...</kbd>.

</ol>

<h2><a name="links" href="#toc">VI. Related Documentation</a></h2>

<h3>VI.a. JSynthLib</h3>
<ul>
  <li><a name="website" href="http://www.jsynthlib.org">JSynthLib Home Page</a>
  <li><a name="cvssite"
  href="http://sourceforge.net/projects/jsynthlib/">JSynthLib
  SourceForge.net Developer Home Page</a>
    <font size="-1">(contains the CVS Repository)</font>
  <li><a name="mailinglist" href="mailto:jsynthlib-devel@lists.sourceforge.net">JSynthLib mailing list</a>
  <li><a name="yahoofiles" href="http://groups.yahoo.com/group/jsynthlib-dev/files/">JSynthLib Yahoo group - file section</a>
  <li><a name="wireprovider"
  href="http://www.geocities.com/ggehnen/">MIDI Provider for
  Windows</a>.  JDK older than 1.4.2 requires this.
</ul>

<h3>VI.b. Java Language</h3>
For overviews, tutorials, examples, guides, and tool documentation, please see:<p>
<a name="javasite" href="http://java.sun.com">Java Home Page</a>

<p>Some selected documents:
<ul>
  <li><a name="tutorial" href="http://java.sun.com/docs/books/tutorial/uiswing/">SUN Java tutorials</a><br>
    <font size="-1">The online tutorials</font>
  <li><a name="javaapi"
  href="http://java.sun.com/j2se/1.4.2/docs/api/">Java<sup><font
  size="-2">TM</font></sup> 2 SDK Version 1.4.2 API specification</a><br>
    <font size="-1">The online 2 SDK Version 1.4.2 API specification</font>
  <li><a name="javadocdownload"
  href="http://java.sun.com/j2se/1.4.2/download.html#docs">Java<sup><font size="-2">TM</font></sup> 2 SDK Version 1.4.2, Standard Edition Documentation</a><br>
    <font size="-1">Downloadable Java 2 SDK Version 1.4.2 documentation</font>
  <li><a name="examples"href="http://java.sun.com/docs/books/javaprog/">The Java Programming Language</a><br>
    <font size="-1">written by Ken Arnold and James Gosling (creators of Java Language).</font>
  <li><a name="codeconv" href="http://java.sun.com/docs/codeconv/index.html">Code Conventions for the Java Programming Language</a><br>
    <font size="-1">Standards and styles for coding Java programs. </font>
  <li><a href="http://java.sun.com/products/jdk/javadoc/writingdoccomments.html">How to Write Doc Comments for Javadoc</a><br>
    <font size="-1">describes the tag conventions SUN follows at Java Software. </font>
  <li><a href="http://java.sun.com/j2se/1.4.2/docs/guide/sound/programmer_guide/contents.html">Java Sound API Programmer's Guide</a><br>
</ul><p>

<a href="http://http://www.jsresources.org/">Java Sound Resources</a>
is a good resource of Java Sound.

<h3>VI.c. MIDI Specification</h3>

<ul>
  <li><a href="http://www.midi.org">MMA (Midi Manufacturer Association)</a><br>
    <font size="-1">The MMA is the original source for information on MIDI (Musical Instrument Digital Interface) technology.</font>
</ul><p>

The <strong>Complete MIDI 1.0 Detailed Specification</strong> isn't
downloadable from the MMA Web site.<br>
But you'll find a MIDI specification for example at
<ul>
  <li><a href="http://www.borg.com/~jglatt/">www.borg.com</a>.
</ul>

<h3>VI.d. Applications</h3>
<ul>
  <li><a name="eclipse" href="http://www.eclipse.org/">Eclipse</a>
  <li><a name="jedit"  href="http://www.jedit.org/">JEdit</a>
  <li><a name="midiox" href="http://www.midiox.com/">MIDI-OX and MIDI York</a>
</ul>

</font>
</body>
</html>
